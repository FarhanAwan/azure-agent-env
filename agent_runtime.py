import logging
import time
from gemini_llm import GeminiLLM
from azure_queries import list_resource_groups, list_key_vaults

logging.basicConfig(level=logging.INFO)

MAX_RETRIES = 3
RETRY_DELAY = 2  # Seconds between retries
BACKOFF_FACTOR = 2  # Exponential backoff multiplier

allowed_functions = {
    "list_resource_groups": list_resource_groups,
    "list_key_vaults": list_key_vaults,
}

def is_transient_error(error):
    """Classify errors as transient (retryable) or permanent."""
    return isinstance(error, (TimeoutError, ConnectionError))

def retry_with_backoff(func, *args, **kwargs):
    """Retry the function on transient errors with exponential backoff."""
    attempt = 0
    while attempt < MAX_RETRIES:
        try:
            return func(*args, **kwargs)
        except Exception as e:
            if not is_transient_error(e):
                raise e  # Don't retry if permanent error
            attempt += 1
            time.sleep(RETRY_DELAY * BACKOFF_FACTOR ** attempt)  # Exponential backoff
            logging.warning(f"Error occurred: {e}. Retrying attempt {attempt}/{MAX_RETRIES}")
    raise Exception("Max retries reached.")

def agent_loop(user_query):
    """Handle the agent loop with retries and error handling."""
    llm = GeminiLLM()
    attempt = 0
    while attempt < MAX_RETRIES:
        try:
            prompt = f"Generate Python Azure SDK code to answer this query: '{user_query}'."
            llm_response = llm.complete(prompt)
            
            if "list_resource_groups" in llm_response:
                result = retry_with_backoff(list_resource_groups)
                return f"Resource Groups: {result}"
            elif "list_key_vaults" in llm_response:
                result = retry_with_backoff(list_key_vaults)
                return f"Key Vaults: {result}"
            else:
                raise ValueError(f"Unsupported query generated by LLM: {user_query}")
        
        except Exception as e:
            logging.error(f"Error processing query '{user_query}': {e}")
            attempt += 1
            if attempt >= MAX_RETRIES:
                return f"Failed after {attempt} attempts: {e}"
            time.sleep(RETRY_DELAY * BACKOFF_FACTOR ** attempt)
